{"version":3,"sources":["util/audio.ts","util/time.ts","components/Graph.tsx","components/Clipper.tsx","components/toggle-button.tsx","settings.ts","components/droparea.tsx","components/select-file.tsx","components/app.tsx","hooks/useDraggingOver.ts","index.tsx"],"names":["rms","pipe","map","x","mean","Math","sqrt","loadFileAsArrayBuffer","file","Promise","resolve","reject","reader","FileReader","readAsArrayBuffer","onload","e","result","onerror","Error","float32ArraytoInt16Array","floatbuffer","int16Buffer","Int16Array","length","i","len","encodeMp3","channels","buffer","a","bitrate","encoder","Mp3Encoder","numberOfChannels","sampleRate","encoded","encodeBuffer","Blob","type","clipChannels","start","end","audioBuffer","getChannelData","extractChannels","channel","subarray","decodeAudio","arrayBuffer","window","AudioContext","webkitAudioContext","decodeAudioData","getRawChannels","audioData","processChannel","samples","chunkSize","ceil","chunks","Array","xs","wait","ms","setTimeout","width","height","margin","innerWidth","innerHeight","Graph","rawChannels","currentTime","duration","trim","useState","data","setData","useEffect","createGraphData","then","pathsRef","useRef","graphData","fill","createEmptyData","xScale","scaleLinear","yDomain","extent","flat","yScale","shape","area","curve","curveBasis","d","y0","y1","select","current","selectAll","join","transition","delay","n","ease","easeBackOut","attr","playheadRef","playheadScale","datum","startMaskRef","endMaskRef","durationScale","startMask","endMask","viewBox","className","id","ref","y","transform","mask","getBaseline","unzip","min","toNumber","left","right","center","Status","ToggleButton","status","onContent","offContent","onChange","onClick","classNames","statusTexts","NONE","READING_FILE","EXPORTING_MP3","Clipper","isPlaying","setPlaying","setDuration","startTime","setStartTime","endTime","setEndTime","setCurrentTime","loop","setLoop","setStatus","setRawChannels","all","updateMetadata","audio","audioRef","onloadedmetadata","onplay","onpause","playPause","useCallback","pause","play","animationFrame","tick","requestAnimationFrame","cancelAnimationFrame","src","URL","createObjectURL","revokeObjectURL","audioContext","blob","document","createElement","setAttribute","href","body","appendChild","click","Slider","value","newValue","max","step","dropzone","accept","multiple","DropArea","children","onDrop","isHidden","useDropzone","getRootProps","getInputProps","isDragActive","isDragReject","SelectFile","dropz","noClick","open","App","setFile","isDraggingOver","setDraggingOver","dragCount","handleDragOver","preventDefault","handleDragEnter","update","handleDragLeave","handleDrop","addEventListener","removeEventListener","useDraggingOver","acceptedFiles","theme","createMuiTheme","palette","primary","main","ReactDOM","render","StrictMode","ThemeProvider","getElementById"],"mappings":"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","file":"static/js/main.7b1c34a9.chunk.js","sourcesContent":["import { Mp3Encoder } from \"lamejs\";\nimport { map, mean, pipe } from \"lodash/fp\";\n\nexport type Channels = [left: Int16Array, right?: Int16Array];\n\nexport const rms = pipe(\n  map((x: number) => x * x),\n  pipe(mean, Math.sqrt),\n);\n\nexport const loadFileAsArrayBuffer = (file: File): Promise<ArrayBuffer> =>\n  new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.onload = (e) => resolve(reader.result as ArrayBuffer);\n    reader.onerror = (e) => reject(new Error(\"Couldn't read file.\"));\n  });\n\nexport function float32ArraytoInt16Array(\n  floatbuffer: Float32Array,\n): Int16Array {\n  var int16Buffer = new Int16Array(floatbuffer.length);\n  for (var i = 0, len = floatbuffer.length; i < len; i++) {\n    if (floatbuffer[i] < 0) {\n      int16Buffer[i] = 0x8000 * floatbuffer[i];\n    } else {\n      int16Buffer[i] = 0x7fff * floatbuffer[i];\n    }\n  }\n  return int16Buffer;\n}\n\nexport async function encodeMp3(\n  channels: Channels,\n  buffer: AudioBuffer,\n  bitrate: number = 128,\n): Promise<Blob> {\n  const encoder = new Mp3Encoder(\n    buffer.numberOfChannels,\n    buffer.sampleRate,\n    bitrate,\n  );\n\n  switch (channels.length) {\n    case 1:\n    case 2: {\n      const encoded = encoder.encodeBuffer(...channels);\n      return new Blob([encoded], { type: \"audio/mp3\" });\n    }\n    default:\n      throw new Error(`Wrong number of channels: ${buffer.numberOfChannels}`);\n  }\n}\n\nexport function extractChannels(audioBuffer: AudioBuffer): Channels {\n  switch (audioBuffer.numberOfChannels) {\n    case 1: {\n      const mono = float32ArraytoInt16Array(audioBuffer.getChannelData(0));\n      return [mono];\n    }\n    case 2: {\n      const left = float32ArraytoInt16Array(audioBuffer.getChannelData(0));\n      const right = float32ArraytoInt16Array(audioBuffer.getChannelData(1));\n      return [left, right];\n    }\n    default:\n      throw new Error(\n        `Wrong number of channels: ${audioBuffer.numberOfChannels}`,\n      );\n  }\n}\n\nexport function clipChannels(\n  buffer: AudioBuffer,\n  start: number,\n  end: number,\n): Channels {\n  const { sampleRate } = buffer;\n  const channels = extractChannels(buffer);\n  return channels.map((channel) =>\n    channel!.subarray(sampleRate * start, sampleRate * end),\n  ) as Channels;\n}\n\n// REFACTOR\n\n/**\n * @deprecated Converting array from buffer is too expensive. Variadic channels are hard to work with.\n */\nexport const getChannels = async (file: File): Promise<number[][]> => {\n  const channels: number[][] = [];\n  const buffer = await loadFileAsArrayBuffer(file);\n  const audioData = await decodeAudio(buffer);\n  for (let i = 0; i < audioData.numberOfChannels; i++) {\n    channels.push(Array.from(audioData.getChannelData(i)));\n  }\n  return channels;\n};\n\n/**\n * Get the decoded audio buffer from a file's array buffer.\n */\nexport async function decodeAudio(\n  arrayBuffer: ArrayBuffer,\n): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const contextClass = window.AudioContext ?? window.webkitAudioContext;\n    const audioContext = new contextClass();\n    audioContext.decodeAudioData(arrayBuffer, resolve, () =>\n      reject(new Error(\"Couldn't decode audio\")),\n    );\n  });\n}\n\n/**\n * Extract the first and second channels from the audio data.\n * If the sound is mono, return the first channel twice.\n */\nexport async function getRawChannels(file: File): Promise<RawChannels> {\n  const buffer = await loadFileAsArrayBuffer(file);\n  const audioData = await decodeAudio(buffer);\n  return [\n    audioData.getChannelData(0),\n    audioData.numberOfChannels > 1\n      ? audioData.getChannelData(1)\n      : audioData.getChannelData(0),\n  ];\n}\n\n/**\n * Parse the raw channel data into graphable data.\n */\nexport function processChannel(channel: Float32Array, samples: number) {\n  const len = channel.length;\n  const chunkSize = Math.ceil(len / samples);\n  const chunks = new Array(samples);\n\n  for (let i = 0; i < samples; i++) {\n    const xs = channel.subarray(chunkSize * i, chunkSize * (i + 1));\n    chunks[i] = rms(xs);\n  }\n\n  return chunks;\n}\n","export async function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import { area, curveBasis, easeBackOut, extent, scaleLinear, select } from \"d3\";\nimport { map, min, pipe, toNumber, unzip } from \"lodash/fp\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { processChannel } from \"../util/audio\";\nimport \"./Graph.css\";\n\nconst width = 1200;\nconst height = 120;\nconst margin = { top: 10, right: 0, bottom: 0, left: 0 };\nconst innerWidth = width - margin.left - margin.right;\nconst innerHeight = height - margin.top - margin.bottom;\n\ntype GraphData = [left: number[], right: number[], center: number[]];\n\ntype GraphProps = {\n  rawChannels: RawChannels | null;\n  currentTime: number;\n  duration: number;\n  trim: [start: number, end: number];\n};\n\nexport default function Graph({\n  rawChannels,\n  currentTime,\n  duration,\n  trim,\n}: GraphProps) {\n  const samples = 200;\n\n  const [data, setData] = useState<GraphData | null>(null);\n  useEffect(() => {\n    setData(null);\n    if (rawChannels) {\n      createGraphData(rawChannels, samples).then(setData);\n    }\n  }, [rawChannels, samples]);\n\n  // update the graph when de data changes\n  const pathsRef = useRef<SVGGElement>(null);\n  useEffect(() => {\n    const graphData = data ?? createEmptyData(samples);\n    const xScale = scaleLinear([0, samples - 1], [0, innerWidth]);\n    const yDomain =\n      data === null ? [0, 1] : (extent(graphData.flat()) as [number, number]);\n    const yScale = scaleLinear(yDomain, [innerHeight, 0]);\n    const shape = area<number>()\n      .curve(curveBasis)\n      .x((d, i) => xScale(i))\n      .y0(innerHeight)\n      .y1(yScale);\n    const delay = (n: number) => {\n      const pos =\n        data === null\n          ? graphData.length - n // reverse\n          : n;\n      return pos * 300;\n    };\n\n    const selection = select(pathsRef.current).selectAll(\"path\");\n    selection\n      .data(graphData)\n      .join(\"path\")\n      .transition()\n      .duration(500)\n      .delay((d, i) => delay(i))\n      .ease(easeBackOut)\n      .attr(\"d\", shape);\n  }, [data, samples]);\n\n  // playhead\n  const playheadRef = useRef<SVGLineElement>(null);\n  const playheadScale = scaleLinear([0, duration], [1, innerWidth - 1]);\n  useEffect(() => {\n    select(playheadRef.current!)\n      .datum(currentTime)\n      .attr(\"x1\", playheadScale)\n      .attr(\"x2\", playheadScale)\n      .attr(\"y1\", 0)\n      .attr(\"y2\", height);\n  }, [currentTime, duration, playheadScale]);\n\n  // mask\n  const startMaskRef = useRef<SVGRectElement>(null);\n  const endMaskRef = useRef<SVGRectElement>(null);\n  useEffect(() => {\n    const durationScale = scaleLinear([0, duration], [0, innerWidth]);\n    const [start, end] = trim;\n    const startMask = startMaskRef.current;\n    const endMask = endMaskRef.current;\n\n    select(startMask)\n      .datum(start)\n      .attr(\"width\", (d) => durationScale(d));\n    select(endMask)\n      .datum(end)\n      .attr(\"x\", (d) => durationScale(d))\n      .attr(\"width\", (d) => durationScale(duration - d));\n  }, [trim, duration]);\n\n  return (\n    <svg\n      width={width}\n      height={height}\n      viewBox={`0 0 ${width} ${height}`}\n      className=\"graph\"\n    >\n      <defs>\n        <mask id=\"overlayMask\">\n          <rect width=\"300\" height=\"100%\" fill=\"white\" ref={startMaskRef} />\n          <rect x=\"100%\" y=\"0\" height=\"100%\" fill=\"white\" ref={endMaskRef} />\n        </mask>\n      </defs>\n\n      <g>\n        <g\n          transform={`translate(${margin.left}, ${margin.top})`}\n          ref={pathsRef}\n          className=\"graph__paths\"\n        />\n\n        <rect\n          x=\"0\"\n          y=\"0\"\n          height={height}\n          width={width}\n          className=\"graph__grayscale-overlay\"\n          mask=\"url(#overlayMask)\"\n        />\n        <rect\n          x=\"0\"\n          y=\"0\"\n          height={height}\n          width={width}\n          className=\"graph__opacity-overlay\"\n          mask=\"url(#overlayMask)\"\n        />\n\n        <line ref={playheadRef} className=\"graph__playhead\" />\n      </g>\n    </svg>\n  );\n}\n\nconst getBaseline = pipe(unzip, map(min), map(toNumber));\n\n/**\n * @todo when the audio is too short, take fewer samples.\n */\nasync function createGraphData(\n  channels: RawChannels,\n  samples: number,\n): Promise<GraphData> {\n  const left = processChannel(channels[0], samples);\n  const right =\n    channels[0] === channels[1] ? left : processChannel(channels[1], samples);\n  const center =\n    channels[0] === channels[1] ? left : getBaseline([left, right]);\n\n  return [left, right, center];\n}\n\nfunction createEmptyData(samples: number): GraphData {\n  return [\n    Array(samples).fill(0),\n    Array(samples).fill(0),\n    Array(samples).fill(0),\n  ];\n}\n","import Slider from \"@material-ui/core/Slider\";\nimport React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport {\n  IoIosInfinite,\n  IoIosPlay,\n  IoMdDownload as IoIosDownload,\n} from \"react-icons/io\";\nimport { clipChannels, encodeMp3, getRawChannels } from \"../util/audio\";\nimport { wait } from \"../util/time\";\nimport Graph from \"./Graph\";\nimport ToggleButton from \"./toggle-button\";\n\nenum Status {\n  NONE,\n  READING_FILE,\n  EXPORTING_MP3,\n}\n\nconst statusTexts: { [k in Status]: string } = {\n  [Status.NONE]: \"\",\n  [Status.READING_FILE]: \"Reading file\",\n  [Status.EXPORTING_MP3]: \"Exporting MP3\",\n};\n\ntype ClipperProps = {\n  file: File;\n};\nexport default function Clipper({ file }: ClipperProps) {\n  const [isPlaying, setPlaying] = useState(false);\n  const [duration, setDuration] = useState(0);\n  const [startTime, setStartTime] = useState(0);\n  const [endTime, setEndTime] = useState(0);\n  const [currentTime, setCurrentTime] = useState(startTime);\n  const [loop, setLoop] = useState(false);\n  const [status, setStatus] = useState<Status>(Status.NONE);\n  const [rawChannels, setRawChannels] = useState<RawChannels | null>(null);\n\n  // decode de audio data\n  useEffect(() => {\n    setRawChannels(null);\n    setStatus(Status.READING_FILE);\n    Promise.all([\n      getRawChannels(file),\n      wait(2000), // add a min time for the operation\n    ]).then(([rawChannels]) => {\n      setRawChannels(rawChannels);\n      setStatus(Status.NONE);\n    });\n  }, [file]);\n\n  const updateMetadata = () => {\n    const audio = audioRef.current!;\n    setDuration(audio.duration);\n    setEndTime(audio.duration);\n    setStartTime(0);\n    audio.currentTime = 0;\n  };\n\n  const audioRef = useRef<HTMLAudioElement>(null);\n  useEffect(() => {\n    audioRef.current!.onloadedmetadata = updateMetadata;\n    audioRef.current!.onplay = () => setPlaying(true);\n    audioRef.current!.onpause = () => setPlaying(false);\n  });\n\n  const playPause = useCallback(() => {\n    const audio = audioRef.current!;\n    if (isPlaying) {\n      audio.pause();\n    } else {\n      audio.play();\n    }\n  }, [isPlaying]);\n\n  // update currentTime\n  useEffect(() => {\n    const audio = audioRef.current!;\n    let animationFrame = 0;\n    const tick = () => {\n      setCurrentTime(audio.currentTime);\n      animationFrame = requestAnimationFrame(tick);\n    };\n    tick();\n    return () => {\n      if (animationFrame) cancelAnimationFrame(animationFrame);\n    };\n  }, []);\n\n  // go back to start time after playing\n  useEffect(() => {\n    const audio = audioRef.current!;\n    if (currentTime >= endTime) {\n      audio.currentTime = startTime;\n      if (!loop) {\n        audio.pause();\n      }\n    }\n  }, [currentTime, endTime, loop, startTime]);\n\n  // load dropped file into the audio element\n  useEffect(() => {\n    const audio = audioRef.current!;\n    audio.src = URL.createObjectURL(file);\n    audio.onload = () => {\n      URL.revokeObjectURL(audio.src);\n    };\n  }, [file]);\n\n  // sync current time with start time\n  useEffect(() => {\n    const audio = audioRef.current!;\n    audio.currentTime = startTime;\n  }, [startTime]);\n\n  const handleSelection = (\n    e: React.ChangeEvent<{}>,\n    newValue: number | number[],\n  ) => {\n    const [start, end] = newValue as [number, number];\n    setStartTime(start);\n    setEndTime(end);\n  };\n\n  async function handleDownload() {\n    // fetch file contents\n    const arrayBuffer = await file.arrayBuffer();\n\n    // decode audio data\n    const audioContext = new AudioContext();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n    // encode mp3\n    const channels = clipChannels(audioBuffer, startTime, endTime);\n    const blob = await encodeMp3(channels, audioBuffer);\n\n    // display audio\n    const a = document.createElement(\"a\");\n    a.setAttribute(\"download\", \"clip.mp3\");\n    a.setAttribute(\"hidden\", \"hidden\");\n    a.href = URL.createObjectURL(blob);\n    document.body.appendChild(a);\n    a.click();\n  }\n\n  return (\n    <div className=\"clipper\">\n      <div className=\"clipper__view\">\n        <Graph\n          currentTime={currentTime}\n          duration={duration}\n          trim={[startTime, endTime]}\n          rawChannels={rawChannels}\n        />\n        <Slider\n          value={[startTime, endTime]}\n          onChange={handleSelection}\n          min={0}\n          max={duration}\n          step={0.001}\n        />\n        <audio ref={audioRef} />\n      </div>\n\n      <div className=\"clipper__controls\">\n        <div className=\"controls\">\n          <div className=\"controls__start\">\n            <ToggleButton\n              status={isPlaying}\n              onContent={<IoIosPlay />}\n              offContent={<IoIosPlay />}\n              onChange={playPause}\n            />{\" \"}\n            <ToggleButton\n              status={loop}\n              onContent={<IoIosInfinite />}\n              offContent={<IoIosInfinite />}\n              onChange={(loop) => setLoop(loop)}\n            />\n          </div>\n          <div className=\"controls__middle\">{statusTexts[status]}</div>\n          <div className=\"controls__end\">\n            <button onClick={handleDownload}>\n              <IoIosDownload />\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import classNames from \"classnames\";\nimport React from \"react\";\n\ntype ToggleButtonProps = {\n  status: boolean;\n  onContent: React.ReactNode;\n  offContent: React.ReactNode;\n  onChange?(status: boolean): void;\n};\nexport default function ToggleButton({\n  status,\n  onContent,\n  offContent,\n  onChange,\n}: ToggleButtonProps) {\n  const handleClick = () => {\n    if (onChange) onChange(!status);\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      className={classNames(\"btn--toggle\", status ? \"btn--on\" : \"btn--off\")}\n    >\n      {status ? onContent : offContent}\n    </button>\n  );\n}\n","export const dropzone = { accept: \"audio/mpeg\", multiple: false };\n","import classNames from \"classnames\";\nimport React from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { dropzone } from \"../settings\";\n\ntype DropAreaProps = {\n  children: React.ReactNode;\n  isHidden: boolean;\n  onDrop: (acceptedFiles: File[]) => void;\n};\nexport default function DropArea({\n  children,\n  onDrop,\n  isHidden,\n}: DropAreaProps) {\n  const {\n    getRootProps,\n    getInputProps,\n    isDragActive,\n    isDragReject,\n  } = useDropzone({ ...dropzone, onDrop });\n\n  return (\n    <div\n      className={classNames(\n        \"drop-area\",\n        isDragActive && \"drop-area--active\",\n        isDragReject && \"drop-area--rejected\",\n        isHidden && \"drop-area--hidden\",\n      )}\n      {...getRootProps()}\n    >\n      <input {...getInputProps()} />\n      {children}\n    </div>\n  );\n}\n","import React from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { dropzone } from \"../settings\";\n\nexport default function SelectFile({ onDrop }) {\n  const dropz = useDropzone({\n    ...dropzone,\n    noClick: true,\n    onDrop,\n  });\n\n  return (\n    <div>\n      <button onClick={dropz.open}>Selecione um arquivo</button>\n      <input {...dropz.getInputProps()} />\n    </div>\n  );\n}\n","import React, { useCallback, useState } from \"react\";\nimport useDraggingOver from \"../hooks/useDraggingOver\";\nimport Clipper from \"./Clipper\";\nimport DropArea from \"./droparea\";\nimport SelectFile from \"./select-file\";\n\nexport default function App() {\n  const [file, setFile] = useState<File | null>(null);\n  const isDraggingOver = useDraggingOver();\n\n  const onDrop = useCallback((acceptedFiles: File[]) => {\n    if (acceptedFiles.length < 1) return;\n    setFile(acceptedFiles[0]);\n  }, []);\n\n  return (\n    <div className=\"app\">\n      <div className=\"layout\">\n        {/* <nav className=\"layout__nav\"></nav> */}\n        <main className=\"layout__content\">\n          <h1>Clipit</h1>\n          {!file && (\n            <div className=\"begin text--center\">\n              <p>\n                Para começar, selecione um arquivo MP3 no seu computador. Você\n                também pode arrastar e soltar o arquivo em qualquer lugar da\n                página.\n              </p>\n              <SelectFile onDrop={onDrop} />\n              <p></p>\n            </div>\n          )}\n          {file && <Clipper file={file} />}\n        </main>\n        {/* <footer className=\"layout__footer\"></footer> */}\n      </div>\n\n      <DropArea isHidden={!isDraggingOver} onDrop={onDrop}>\n        🔥 drop it like it's hot 🔥\n      </DropArea>\n    </div>\n  );\n}\n","import { useEffect, useState } from \"react\";\n\nexport default function useDraggingOver() {\n  const [isDraggingOver, setDraggingOver] = useState(false);\n\n  useEffect(() => {\n    let dragCount = 0;\n\n    function handleDragOver(e: DragEvent) {\n      e.preventDefault();\n    }\n    function handleDragEnter(e: DragEvent) {\n      dragCount++;\n      update();\n    }\n    function handleDragLeave(e: DragEvent) {\n      dragCount--;\n      update();\n    }\n    function handleDrop(e: DragEvent) {\n      dragCount = 0;\n      update();\n    }\n    function update() {\n      setDraggingOver(dragCount > 0);\n    }\n\n    window.addEventListener(\"dragover\", handleDragOver);\n    window.addEventListener(\"dragenter\", handleDragEnter);\n    window.addEventListener(\"dragleave\", handleDragLeave);\n    window.addEventListener(\"drop\", handleDrop);\n\n    return () => {\n      window.removeEventListener(\"dragover\", handleDragOver);\n      window.removeEventListener(\"dragenter\", handleDragEnter);\n      window.removeEventListener(\"dragleave\", handleDragLeave);\n      window.removeEventListener(\"drop\", handleDrop);\n    };\n  }, []);\n\n  return isDraggingOver;\n}\n","import { createMuiTheme, ThemeProvider } from \"@material-ui/core\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/app\";\nimport \"./styles.css\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#8134af\",\n    },\n  },\n});\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// import * as serviceWorker from './serviceWorker';\n// serviceWorker.unregister();\n"],"sourceRoot":""}